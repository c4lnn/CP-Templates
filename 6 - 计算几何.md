# 计算几何

## 点

```cpp
const DB EPS=1e-8;
const DB PI=acos(-1);
int sgn(DB x) {return fabs(x)<EPS?0:(x>0?1:-1);}
struct P {
    DB x,y;
    P() {}
    P(DB x,DB y):x(x),y(y) {}

    bool operator == (const P &a) const {return !sgn(x-a.x)&&!sgn(y-a.y);}
    bool operator < (const P &a) const {return sgn(x-a.x)<0||sgn(x-a.x)==0&&sgn(y-a.y)<0;}

    P operator + (const P &a) const {return P(x+a.x,y+a.y);}
    P operator - (const P &a) const {return P(x-a.x,y-a.y);}
    P operator * (const DB &k) const {return P(x*k,y*k);}
    P operator / (const DB &k) const {return P(x/k,y/k);}

    DB operator * (const P &a) const {return x*a.x+y*a.y;}  // 点积
    DB operator ^ (const P &a) const {return x*a.y-y*a.x;}  // 叉积
    // 这个点与 a，b 所成的夹角
    DB rad(const P &a,const P &b) {return fabs(atan2(fabs((a-*this)^(b-*this)),(a-*this)*(b-*this)));}

    DB len() {return hypot(x,y);}  // 点到原点的距离
    DB len2() {return x*x+y*y;}  // 点到原点的距离的平方
    DB dist(const P &p) {return hypot(x-p.x,y-p.y);}  // 两点距离

    P rotleft() {return P(-y,x);}  // 绕原点逆时针旋转 90 度
    P rotright() {return P(y,-x);}  // 绕原点顺时针旋转 90 度
    P rotate(const P &p,const DB &angle) {  // 绕 P 点逆时针旋转 angle 度
        P v=*this-p;
        DB c=cos(angle),s=sin(angle);
        return P(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);
    }
};
```

## 线

```cpp
struct L {
    P s,t;
    L() {}
    L(P s,P t):s(s),t(t) {}

    bool operator == (const L &a) const {return s==a.s&&t==a.t;}

    int relation(const P &p) {return sgn((p-s)^(t-s));} // -1在左侧，1在右侧，0在直线上

    P cross_point(const L &a) { // 直线交,需保证不平行不重合
        DB s1=(t-s)^(a.s-s);
        DB s2=(t-s)^(a.t-s);
        return (a.s*s2-a.t*s1)/(s2-s1);
    }
    bool parallel(const L &a) {return sgn((t-s)^(a.t-a.s))==0;} // 平行
    bool P_on_seg(const P &p) {
        return !sgn((p-s)^(t-s))&&sgn((p-s)*(p-t))<=0;
    }
    // 求 a, b 直线交是否在线段 b 上无需判断 sgn((p-s)^(t-s))
    // 因为已经保证了该点在线段 b 或线段 b 的延长线上，加上会有精度问题
};
```

## 圆

```cpp
struct C {
    P p;
    DB r;
    C() {}
    C(P p,DB r):p(p),r(r) {}
};
P compute_circle_center(P a,P b) {return(a+b)/2;} // 两点定圆
P compute_circle_center(P a,P b,P c) { // 三点定圆
    b=(a+b)/2;
    c=(a+c)/2;
    return L(b,b+(a-b).rotright()).cross_point({c,c+(a-c).rotright()});
}
bool p_in_circle(P p,C c) { // 点是否不在圆外
    return sgn(p.dist(c.p)-c.r)<=0;
}
```

## 凸包

```cpp
void andrew() { // 凸包
    sort(p+1,p+1+n);
    for(int i=1;i<=min(n,2);i++) stk[++top]=p[i];
    if(n==2&&stk[1]==stk[2]) --top;
    if(n<=2) return;
    for(int i=3;i<=n;i++) {
        while(top>=2&&sgn((stk[top]-stk[top-1])^(p[i]-stk[top]))<=0) --top;
        stk[++top]=p[i];
    }
    int temp=top;
    stk[++top]=p[n-1];
    for(int i=n-1;i>=1;i--) {
        while(top>temp&&sgn((stk[top]-stk[top-1])^(p[i]-stk[top]))<=0) --top;
        stk[++top]=p[i];
    }
    if(top==2&&stk[1]==stk[2]) --top;
    // 凸包上有 top - 1 个点，1 号点被记录了两次，分别为 stk[1] 和 stk[top]
}
```

## 最小圆覆盖

```cpp
C min_circle_cover(const vector<P> &T) {
    vector<P> a(ALL(T));
    random_shuffle(ALL(a));
    P c=a[0];DB r=0;
    for(int i=1;i<SZ(a);i++) if(!p_in_circle(a[i],{c,r})) {
        c=a[i];r=0;
        for(int j=0;j<i;j++) if(!p_in_circle(a[j],{c,r})) {
            c=compute_circle_center(a[i],a[j]);
            r=a[j].dist(c);
            for(int k=0;k<j;k++) if(!p_in_circle(a[k],{c,r})) {
                c=compute_circle_center(a[i],a[j],a[k]);
                r=a[k].dist(c);
            }
        }
    }
    return {c,r};
}
```

