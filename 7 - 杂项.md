# 杂项

## 排序

### 归并排序

```cpp
int a[N],temp[N];
void merge(int l,int mid,int r) {
    int i=l,j=mid+1;
    int t=l;
    while(i<=mid&&j<=r) {
        if(a[i]<=a[j]) temp[t++]=a[i++];
        else temp[t++]=a[j++];
    }
    while(i<=mid) temp[t++]=a[i++];
    while(j<=r) temp[t++]=a[j++];
    for(int i=l;i<=r;i++) a[i]=temp[i];
}
void merge_sort(int l,int r) {
    if(l<r) {
        int mid=l+r>>1;
        merge_sort(l,mid);
        merge_sort(mid+1,r);
        merge(l,mid,r);
    }
}
```

### 快速排序

```cpp
void quick_sort(int l,int r) {
    if(l<r) {
        int i=l,j=r;
        int key=a[l];
        while(i<j) {
            while(i<j&&a[j]>key) j--;
            if(i<j) a[i++]=a[j];
            while(i<j&&a[i]<key) i++;
            if(i<j) a[j--]=a[i];
        }
        a[i]=key;
        quick_ort(l,i-1);
        quick_ort(i+1,r);
    }
}
```

## 离散化

```cpp
for(int i=1;i<=n;i++) b.PB(a[i]);
sort(ALL(b));
b.resize(unique(ALL(b))-b.begin());
for(int i=1;i<=n;i++) a[i]=lower_bound(ALL(b),a[i])-b.begin()+1; // 最小值为1
```

## 二分

- 整数最小值

```cpp
int find(int l,int r) {
    while(l<r) {
        int mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    return l;
}
```

- 整数最大值

```cpp
int find(int l, int r) { // 最大值
    while(l<r) {
        int mid=l+r+1>>1;
        if (check(mid)) l=mid;
        else r=mid-1;
    }
    return l;
}
```

- 实数

```cpp
DB find(DB l,DB r) { // 实数二分
    for(int i=0;i<10000;i++) {
        DB mid=(l+r)/2.0;
      	if(check(mid)) l=mid;
      	else r=mid;
    }
    return l;
}
```

## 三分

- 三分用来寻找单峰函数或单谷函数的极值
-  以寻找极大值为例
-  实数三分

```cpp
DB EPS=1e-8;
while(r-l>EPS) {
    DB mid=(r-l)/3.0;
    if(calc(l+mid)>calc(r-mid)) r=r-mid;
    else l=l+mid;
}
cout<<calc(l)<<'\n';
```

- 整数三分

```cpp
while(r-l>10) {
    int mid=(r-l)/3;
    if(calc(l+mid)>calc(r-mid)) r=r-mid;
    else l=l+mid;
}
for(int i=l;i<=r;i++) ans=max(ans,calc(i));
cout<<ans<<'\n';
```

## 高精度

```cpp
struct bign {
    int len;
    int num[1005];
    bign() {
        len=1;
        memset(num,0,sizeof num);
    }
    bool operator < (const bign &a) const {
        if(len!=a.len) return len<a.len;
        for(int i=len;i>=1;i--) if(num[i]!=a.num[i]) return num[i]<a.num[i];
        return false;
    }
    bool operator > (const bign &a) const {return a<*this;}
    bool operator <= (const bign &a) const {return !(a<*this);}
    bool operator >= (const bign &a) const {return !(*this<a);}
    bool operator != (const bign &a) const {return a<*this||*this<a;}
    bool operator == (const bign &a) const {return !(a<*this)&&!(*this<a);}
};
bign get(const string &s) {
    bign res;
    res.len=SZ(s);
    for(int i=1;i<=res.len;i++) res.num[i]=s[res.len-i]-'0';
    return res;
}
bign get(int n) {
    bign res;
    while(n) {
        res.num[res.len++]=n%10;
        n/=10;
    }
    if(res.len>1) res.len--;
    return res;
}
void print(bign a) {
    for(int i=a.len;i;i--) cout<<a.num[i];
    cout<<'\n';
}
bool non_zero(bign T) {
    return T.len>1||T.len==1&&T.num[1];
}
bign operator + (bign a,bign b) {
    bign res;
    res.len=max(a.len,b.len);
    int x=0;
    for(int i=1;i<=res.len;i++) {
        res.num[i]=x+a.num[i]+b.num[i];
        x=res.num[i]/10;
        res.num[i]%=10;
    }
    if(x) res.num[++res.len]=x;
    return res;
}
bign operator - (bign a,bign b) { // a > b
    bign res;
    res.len=max(a.len,b.len);
    for(int i=1;i<=res.len;i++) {
        if(a.num[i]<b.num[i]) --a.num[i+1],a.num[i]+=10;
        res.num[i]=a.num[i]-b.num[i];
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign operator * (bign a,int b) {
    bign res;
    int x=0;
    for(int i=1;i<=a.len;i++) {
        x+=a.num[i]*b;
        res.num[res.len++]=x%10;
        x/=10;
    }
    while(x) {
        res.num[res.len++]=x%10;
        x/=10;
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign operator * (bign a,bign b) {
    bign res;
    res.len=a.len+b.len;
    for(int i=1;i<=res.len;i++) res.num[i]=0;
    for(int i=1;i<=a.len;i++) {
        int x=0;
        for(int j=1;j<=b.len;j++) {
            res.num[i+j-1]+=a.num[i]*b.num[j]+x;
            x=res.num[i+j-1]/10;
            res.num[i+j-1]%=10;
        }
        res.num[i+b.len]+=x;
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign operator / (bign a,int b) {
    bign res;
    res.len=a.len;
    for(int i=a.len,t=0;i>=1;i--) {
        t=t*10+a.num[i];
        if(t>=b) res.num[i]=t/b,t%=b;
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign operator / (bign a,bign b) {
    bign res,x;
    res.len=a.len;
    for(int i=1;i<=res.len;i++) res.num[i]=0;
    for(int i=a.len;i>=1;i--) {
        x=x*10; // bign * int
        x.num[1]=a.num[i];
        while(x>b||x==b) {
            x=x-b; // bign - bign
            res.num[i]++;
        }
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign operator % (bign a,bign b) {
    bign res;
    for(int i=a.len;i>=1;i--) {
        res=res*10; // bign * int
        res.num[1]=a.num[i];
        while(res>b||res==b) res=res-b; // bign - bign
    }
    while(res.len>1&&res.num[res.len]==0) res.len--;
    return res;
}
bign gcd(bign a,bign b) {
    return non_zero(b)?gcd(b,a%b):a;
}
bign qpow(bign a,bign b,bign m) {
    bign ret;
    ret.num[1]=1;
    while(non_zero(b)) {
        if(b.num[1]&1) ret=ret*a%m;
        a=a*a%m;
        b=b/2;
    }
    return ret;
}
```

## 浮点数的精度问题

`int sgn(double x) {return fabs(x)<eps?0:(x>0?1:-1);}`

| 传统意义 | 修正写法1       | 修正写法2         |
| -------- | --------------- | ----------------- |
| a == b   | sgn(a - b) == 0 | fabs(a - b) < eps |
| a != b   | sgn(a - b) != 0 | fabs(a - b) > eps |
| a < b    | sgn(a - b) < 0  | a - b < -eps      |
| a <= b   | sgn(a - b) <= 0 | a - b < eps       |
| a > b    | sgn(a - b) > 0  | a - b > eps       |
| a >= b   | sgn(a - b) >= 0 | a - b > -eps      |

## Lowbit 前缀和

```cpp
int solve(int n) {
    int res=0;
    n++;
    for(int i=1;n>1;n-=(n>>1),i<<=1) res+=i*(n>>1);
    return res;
}
```

## 随机数

```cpp
mt19937 mt(time(0));
uniform_int_distribution<int> rd1(0,10000); //   整数
uniform_real_distribution<double> rd2(0,1); // 浮点数
cout<<rd1(mt)<<' '<<rd2(mt)<<'\n';
```

## 细节处理

- (int)(x).size()
- 1ll<<k
- 上取整和 GCD 注意负数
- 图论问题注意图不连通
- 初始化注意 $0$ 和 $n+1$
- 看清题目是从 $0$ 还是 $1$ 开始
- 数组大小要开够
- 字符串问题注意字符集
- 二分注意上下界